<!-- This is for the actual single article -->


<!DOCTYPE html>
<html lang="en">
<head>
  <title>SSH | Planet Express</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
<meta name="description" content="SSH usage"><meta name="author" content="walchko">  <meta name="viewport" content="initial-scale=1, maximum-scale=1" />
  <meta http-equiv="Cache-Control" content="max-age=604800, must-revalidate" />
  <link href="../../../../theme/css/screen.css" rel="stylesheet" type="text/css" />
  <link href="../../../../theme/css/pygments.css" rel="stylesheet" type="text/css" />
  <link rel="icon" href="../../../../favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="../../../../favicon.ico" type="image/x-icon">
</head>
<body>
<div id="outer-wrapper">
<div id="header-wrapper">
  <div class="logo"><a href="../../../..">Planet Express</a></div>
  <div class="small">Our crew is replaceable. Your package isn't.</div>
  <div class="nav">
  <li><a href="../../../../about.html">About Me</a></li>
  <li><a href="../../../../colophon.html">Colophon</a></li>
  <li><a href="../../../../categories.html">Topics</a></li>
  <li><a href="../../../../archives.html">Blog</a></li>
  </div>
  <div class="nav social">
<ul>
    <li><a href="http://github.com/walchko"><i class="fa fa-github-alt fa-2x"></i></a></li>
    <li><a href="http://stackoverflow.com/users/5374768/kevin"><i class="fa fa-stack-overflow fa-2x"></i></a></li>
    <li><a href="http://raspberrypi.stackexchange.com/users/1677/kevin"><i class="fa fa-stack-exchange fa-2x"></i></a></li>
</ul>  </div>
</div>    <div id="main">

<!--  -->

<h2><a href="../../../../posts/2012/09/ssh">SSH</a></h2>
<h5><i class="icon-feather"></i> Mon 10 September 2012
<i class="icon-bookmarks"></i>
</h5>

<div class="figure align-center">
<img alt="" src="../../../../blog/computers/pics/ssh.jpg" style="width: 200px;" />
</div>
<p>Secure Shell (<a class="reference external" href="http://www.openssh.org">SSH</a>) is a cryptographic
network protocol for secure data communication, remote shell services or
command execution and other secure network services between two
networked computers that connects, via a secure channel over an insecure
network, a server and a client (running SSH server and SSH client
programs, respectively). The protocol specification distinguishes
between two major versions that are referred to as SSH-1 and SSH-2.</p>
<p>The best-known application of the protocol is for access to shell
accounts on Unix-like operating systems, but it can also be used in a
similar fashion for accounts on Windows. It was designed as a
replacement for Telnet and other insecure remote shell protocols such as
the Berkeley rsh and rexec protocols, which send information, notably
passwords, in plaintext, rendering them susceptible to interception and
disclosure using packet analysis. The encryption used by SSH is intended
to provide confidentiality and integrity of data over an unsecured
network, such as the Internet. <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<div class="section" id="key-types">
<h2>Key Types</h2>
<p><a class="reference external" href="http://stackoverflow.com/questions/2841094/what-is-the-difference-between-dsa-and-rsa">Source</a></p>
<p>DSA is faster in signing, but slower in verifying. A DSA key of the same strength as
RSA (1024 bits) generates a smaller signature. An RSA 512 bit key has been cracked, but
only a 280 DSA key.</p>
<p>Also note that DSA can only be used for <strong>signing/verification</strong>, whereas RSA can be
used for <strong>encryption/decrypt</strong> as well.</p>
</div>
<div class="section" id="summary-of-useful-commands">
<h2>Summary of Useful Commands</h2>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="51%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Command</th>
<th class="head">Example</th>
<th class="head">Use</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ssh</td>
<td>ssh <a class="reference external" href="mailto:kevin&#64;thor.local">kevin&#64;thor.local</a></td>
<td>login to a computer</td>
</tr>
<tr><td>ssh-keygen</td>
<td>ssh-keygen</td>
<td>generate an ssh key</td>
</tr>
<tr><td>ssh-keygen</td>
<td>ssh-keygen -lvf</td>
<td>view the key finger print</td>
</tr>
<tr><td>ssh-copy-id</td>
<td>ssh-copy-id <a class="reference external" href="mailto:kevin&#64;loki.local">kevin&#64;loki.local</a></td>
<td>copy key to remote server</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="key-generation">
<h2>Key Generation</h2>
<p>To increase security, you can disable password logins and rely on ssh
public keys. To do this, take a look
<a class="reference external" href="https://wiki.archlinux.org/index.php/SSH_Keys">here</a> for details.
Basic steps are:</p>
<ol class="arabic">
<li><p class="first">Generate an ssh key pair using either RSA (2048-4096 bit) or DSA
(1024 bit) both public and private keys. They will be stored in
<tt class="docutils literal"><span class="pre">~/.ssh</span></tt> with the public key having .pub appended to the end. Two ways to
generate keys are shown below (pick one).</p>
<pre class="literal-block">
ssh-keygen -t dsa -b 1024 -C &quot;$(whoami)&#64;$(hostname)-$(date)&quot;
ssh-keygen -t rsa -b 4096 -C &quot;$(whoami)&#64;$(hostname)-$(date)&quot;
</pre>
<p>Note you can create a key for a different username if you change
$(whoami) to the user name you want. If no type is specified, the default is RSA
2048 bits.</p>
<pre class="literal-block">
[kevin&#64;Tardis ~]$ ssh-keygen -C &quot;test&#64;$(hostname)-$(date)&quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/kevin/.ssh/id_rsa): test
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in test.
Your public key has been saved in test.pub.
The key fingerprint is:
00:04:27:9d:7e:33:6f:65:1c:a5:e0:c3:82:5d:7b:92 test&#64;Tardis.local-Tue Apr 21 22:29:40 MDT 2015
The key's randomart image is:
+--[ RSA 2048]----+
|  o++.  o  ..    |
|   oo+ + +..     |
|   .. + E.o.     |
|    . +o ++      |
|     . +So       |
|        o        |
|       .         |
|                 |
|                 |
+-----------------+
</pre>
<p>Also note, it is advisable you create a strong pass phrase that you won't forget. However,
I typically do not create one. But it does add an added level of protection.</p>
</li>
<li><p class="first">Copy the public key (.pub) to the server you will connect to:</p>
<pre class="literal-block">
ssh-copy-id username&#64;remote-server.org
</pre>
<p>This will update ~/.ssh/authorized_keys in the process. <strong>Note:</strong> <tt class="docutils literal"><span class="pre">ssh-copy-id</span></tt>
may need to be installed. Most Linux/Unix systems should have this, but for OSX do
<tt class="docutils literal">brew install <span class="pre">ssh-copy-id</span></tt>. Also ensure the correct protections are on the file by:</p>
<pre class="literal-block">
chmod 600 ~/.ssh/authorized_keys
</pre>
</li>
<li><p class="first">Edit /etc/ssh/sshd_config to disable password logins.</p>
<pre class="literal-block">
PasswordAuthentication no
ChallengeResponseAuthentication no
</pre>
</li>
</ol>
</div>
<div class="section" id="ssh-key-finger-prints">
<h2>SSH Key Finger Prints</h2>
<p>To view the finger print of a key:</p>
<pre class="literal-block">
[kevin&#64;Tardis ~]$ ssh-keygen -lvf ~/.ssh/id_rsa.pub
    2048 b1:58:41:c5:93:b3:bc:c7:34:5b:e8:be:bc:15:ff:55  kevin&#64;tardis.local (RSA)
    +--[ RSA 2048]----+
    |       .oo..     |
    |         .=      |
    |        o. + .   |
    |       o oo + .  |
    |      . S  = +. E|
    |          . =  o.|
    |           o  . o|
    |           ...  o|
    |            +o  .|
    +-----------------+
</pre>
<p>This tells you the type of key (e.g., RSA or DSA), the bit size, what email/account it is
tied to, and a graphical representation of the key. In this case, the 2048 bits of my public
RSA key.</p>
</div>
<div class="section" id="config">
<h2>Config</h2>
<p>By default, ssh uses id_rsa.pub. If you want to match a specific key to a specific host, you need
a <tt class="docutils literal"><span class="pre">~/.ssh/config</span></tt> file.  Example:</p>
<pre class="literal-block">
Host bitbucket.org
 IdentityFile ~/.ssh/bitbucket_rsa
Host github.com
 IdentityFile ~/.ssh/github_rsa
</pre>
</div>
<div class="section" id="ssh-hacks">
<h2>16 SSH Hacks</h2>
<p>The original source for this work is
<a class="reference external" href="http://www.itworld.com/it-managementstrategy/261500/16-ultimate-openssh-hacks">here</a></p>
<p>So you think you know OpenSSH inside and out? Test your chops against
this hit parade of 16 expert tips and tricks, from identifying
monkey-in-the-middle attacks to road warrior security to attaching
remote screen sessions. Follow the countdown to the all-time best
OpenSSH command!</p>
<p><a class="reference external" href="xhttp://www.itworld.com/nls_unixssh0500506">Running SSH on a non-standard
port</a></p>
<div class="section" id="ssh-tips-16-14-detecting-mitm-attacks">
<h3>SSH tips #16-14:Detecting MITM attacks</h3>
<p>When you log into a remote computer for the first time, you are asked if
you want to accept the remote host's public key. Well how in the heck do
you know if you should or not? If someone perpetrated a successful
monkey-in-the-middle attack, and is presenting you with a fake key so
they can hijack your session and steal all your secrets, how are you
supposed to know? You can know, because when new key pairs are created
they also create a unique fingerprint and randomart image:</p>
<pre class="literal-block">
$ ssh-keygen -t rsa -C newserver -f .ssh/newkey

Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in .ssh/newkey.
Your public key has been saved in .ssh/newkey.pub.
The key fingerprint is:
44:90:8c:62:6e:53:3b:d8:1a:67:34:2f:94:02:e4:87 newserver
The key's randomart image is:
+--[ RSA 2048]----+
|oo   +.o.        |
|. = B o.         |
| E X +  .        |
|  B B ..         |
| . * o  S        |
|  .              |
|                 |
|                 |
|                 |
+-----------------+
</pre>
</div>
<div class="section" id="ssh-tip-16-retrieve-the-fingerprint-and-randomart-image-of-an-ssh-key">
<h3>SSH tip #16: Retrieve the fingerprint and randomart image of an SSH key</h3>
<p>If you make a copy of this when you create new encryption keys, then you
can fetch a key's fingerprint and randomart image anytime to compare and
make sure they have not changed:</p>
<pre class="literal-block">
$ ssh-keygen -lvf  keyname
</pre>
</div>
<div class="section" id="ssh-tip-15-view-all-fingerprints-and-randomart-images-in-known-hosts">
<h3>SSH tip #15: View all fingerprints and randomart images in known_hosts</h3>
<p>And you can see all of them in your ~/.ssh/known_hosts file:</p>
<pre class="literal-block">
$ ssh-keygen -lvf ~/.ssh/known_hosts
</pre>
</div>
<div class="section" id="ssh-tip-14-verify-server-keys">
<h3>SSH tip #14: Verify server keys</h3>
<p>You can see the fingerprint and randomart for any computer you're
logging into by configuring/etc/ssh/ssh_config on your client computer.
Simply uncomment the VisualHostKey option and set it to yes:</p>
<pre class="literal-block">
VisualHostKey yes
</pre>
<p>Then login to any remote computer to test it:</p>
<pre class="literal-block">
$ ssh user&#64;host2
Host key fingerprint is 66:a1:2a:23:4d:5c:8b:58:e7:ef:2f:e5:49:3b:3d:32
+--[ECDSA  256]---+
|                 |
|                 |
|  . o   .        |
| + = . . .       |
|. + o . S        |
| o   o oo        |
|. + . .+ +       |
| . o .. E o      |
|      .o.+ .     |
+-----------------+

user&#64;host2's password:
</pre>
<p>Obviously you need a secure method of getting verified copies of the
fingerprint and randomart images for the computers you want to log into.
Like a hand-delivered printed copy, encrypted email, the scp command,
secure ftp, read over the telephone...The risk of a successful MITM
attack is small, but if you can figure out a relatively painless
verification method it's cheap insurance.</p>
</div>
<div class="section" id="ssh-tip-13-attach-to-a-remote-gnu-screen-session">
<h3>SSH tip #13: Attach to a remote GNU screen session</h3>
<p>You can attach a GNU screen session remotely over SSH; in this example
we'll open a GNU screen session on host1, and connect to it from host2.
First open and then detach a screen session on host1, named testscreen:</p>
<pre class="literal-block">
host1 ~ $ screen -S testscreen
</pre>
<p>Then detach from your screen session with the keyboard combination
Ctrl+a+d:</p>
<pre class="literal-block">
[detached from 3829.testscreen]
</pre>
<p>You can verify that it's still there with this command:</p>
<pre class="literal-block">
host1 ~ $ screen -ls
</pre>
<p>There is a screen on:</p>
<pre class="literal-block">
3941.testscreen (03/18/2012 12:43:42 PM) (Detached)
1 Socket in /var/run/screen/S-host1.
</pre>
<p>Then re-attach to your screen session from host2:</p>
<pre class="literal-block">
host1 ~ $ ssh -t terry&#64;uberpc screen -r testscreen
</pre>
<p>You don't have to name the screen session if there is only one.</p>
</div>
<div class="section" id="vssh-tip-12-launch-a-remote-screen-session">
<h3>vSSH tip #12: Launch a remote screen session</h3>
<p>What if you don't have a running screen session? No worries, because you
can launch one remotely:</p>
<pre class="literal-block">
host1 ~ $ ssh -t user&#64;host2 /usr/bin/screen -xRR
</pre>
</div>
<div class="section" id="ssh-tip-11-sshfs-is-better-than-nfs">
<h3>SSH tip #11: SSHFS is better than NFS</h3>
<p>sshfs is better than NFS for a single user with multiple machines. I
keep a herd of computers running because it's part of my job to always
be testing stuff. I like having nice friendly herds of computers. Some
people collect Elvis plates, I gather computers. At any rate opening
files one at a time over an SSH session for editing is slow; with sshfs
you can mount entire directories from remote computers. First create a
directory to mount your sshfs share in:</p>
<pre class="literal-block">
$ mkdir remote2
</pre>
<p>Then mount whatever remote directory you want like this:</p>
<pre class="literal-block">
$ sshfs user&#64;remote2:/home/user/documents remote2/
</pre>
<p>Now you can browse the remote directory just as though it were local,
and read, copy, move, and edit files all you want. The neat thing about
sshfs is all you need is sshd running on your remote machines, and
thesshfs command installed on your client PCs.</p>
</div>
<div class="section" id="ssh-tip-10-log-in-and-run-a-command-in-one-step">
<h3>SSH tip #10: Log in and run a command in one step</h3>
<p>You can log in and establish your SSH session and then run commands, but
when you have a single command to run why not eliminate a step and do it
with a single command? Suppose you want to power off a remote computer;
you can log in and run the command in one step:</p>
<pre class="literal-block">
carla&#64;local:~$ ssh user&#64;remotehost sudo poweroff
</pre>
<p>This works for any command or script. (The example assumes you have a
sudo user set up with appropriate restrictions, because allowing a root
login over SSH is considered an unsafe practice.) What if you want to
run a long complex command, and don't want to type it out every time?
One way is to put it in a Bash alias and use that. Another way is to put
your long complex command in a text file and run it according to tip #9.</p>
</div>
<div class="section" id="ssh-tip-9-putting-long-commands-in-text-files">
<h3>SSH tip #9: Putting long commands in text files</h3>
<p>Put your long command in a plain text file on your local PC, and then
use it this way to log in and run it on the remote PC:</p>
<pre class="literal-block">
carla&#64;local:~$ ssh user&#64;remotehost &quot;`cat filename.txt`&quot;
</pre>
<p>Mind that you use straight quotations marks and not fancy ones copied
from a Web page, and back-ticks, not single apostrophes.</p>
</div>
<div class="section" id="vssh-tip-8-copy-public-keys-the-easy-way">
<h3>vSSH tip #8: Copy public keys the easy way</h3>
<p>The ssh-copy-id command is not as well-known as it should be, which is a
shame because it is a great time-saver. This nifty command copies your
public key to a remote host in the correct format, and to the correct
directory. It even has a safety check that won't let you copy a private
key by mistake. Specify which key you want to copy, like this:</p>
<pre class="literal-block">
$ ssh-copy-id -i .ssh/id_rsa.pub user&#64;remote
</pre>
</div>
<div class="section" id="ssh-tip-7-give-ssh-keys-unique-names">
<h3>SSH tip #7: Give SSH keys unique names</h3>
<p>Speaking of key names, did you know you can name them anything you want?
This helps when you're administering a number of remote computers, like
this example which creates then private key web-admin and public key
web-admin.pub:</p>
<pre class="literal-block">
$ ssh-keygen -t rsa -f .ssh/web-admin
</pre>
</div>
<div class="section" id="ssh-tip-6-give-ssh-keys-informative-comments">
<h3>SSH tip #6: Give SSH keys informative comments</h3>
<p>Another useful way to label keys is with a comment:</p>
<pre class="literal-block">
$ ssh-keygen -t rsa -C &quot;downtown lan webserver&quot; -f .ssh/web-admin
</pre>
<p>Then you can read your comment which is appended to the end of the
public key.</p>
</div>
<div class="section" id="ssh-tip-5-read-public-key-comments">
<h3>SSH tip #5: Read public key comments</h3>
<pre class="literal-block">
$ less .ssh/web-admin.pub

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC1

[snip] KCLAqwTv8rhp downtown lan webserver
</pre>
</div>
<div class="section" id="ssh-tip-4-logging-in-with-server-specific-keys">
<h3>SSH tip #4: Logging in with server-specific keys</h3>
<p>Then when you log in, specify which key to use with the -i switch:</p>
<pre class="literal-block">
$ ssh -i .ssh/web-admin.pub user&#64;webserver
</pre>
</div>
<div class="section" id="ssh-tip-3-fast-easy-known-hosts-key-management">
<h3>SSH tip #3: Fast easy known_hosts key management</h3>
<p>I love this one because it's a nice time-saver, and it keeps my
~/.ssh/known_hosts files tidy: using ssh-keygen to remove host keys
from the ~/.ssh/known_hosts file. When the remote machine gets new SSH
keys you'll get a warning, when you try to log in, that the key has
changed. Using this is much faster than manually editing the file and
counting down to the correct line to delete:</p>
<pre class="literal-block">
$ ssh-keygen -R remote-hostname
</pre>
<p>Computers are supposed to make our lives easier, and it's ever so lovely
when they do.</p>
</div>
<div class="section" id="ssh-tip-2-ssh-tunnel-for-road-warriors">
<h3>SSH tip #2: SSH tunnel for road warriors</h3>
<p>When you're at the mercy of hotel and coffee shop Internet, a nice
secure SSH tunnel makes your online adventures safer. To make this work
you need a server that you control to act as a central node for escaping
from hotspot follies. I have a server set up at home to accept remote
SSH logins, and then use an SSH tunnel to route traffic through it. This
is useful for a lot of different tasks. For example I can use my normal
email client to send email, instead of hassling with Web mail or
changing SMTP server configuration, and all traffic between my laptop
and home server is encrypted. First create the tunnel to your personal
server:</p>
<pre class="literal-block">
carla&#64;hotel:~$ ssh -f carla&#64;homeserver.com -L 9999:homeserver.com:25 -N
</pre>
<p>This binds port 9999 on your mobile machine to port 25 on your remote
server. The remote port must be whatever you've configured your server
to listen on. Then configure your mail client to use localhost:9999 as
the SMTP server and you're in business. I use Kmail, which lets me
configure multiple SMTP server accounts and then choose which one I want
to use when I send messages, or simply change the default with a mouse
click. You can adapt this for any kind of service that you normally use
from your home base, and need access to when you're on the road.</p>
</div>
<div class="section" id="favorite-ssh-tip-evading-silly-web-restrictions">
<h3>1 Favorite SSH tip: Evading silly web restrictions</h3>
<p>The wise assumption is that any public Internet is untrustworthy, so you
can tunnel your Web surfing too. My #1 SSH tip gets you past
untrustworthy networks that might have snoopers, and past any barriers
to unfettered Web-surfing. Just like in tip #2 you need a server that
you control to act as a secure relay; first setup an SSH tunnel to this
server:</p>
<pre class="literal-block">
carla&#64;hotel:~$ ssh -D 9999 -C carla&#64;homeserver.com
</pre>
<p>Then configure your Web browser to use port 9999 as a SOCKS 5 proxy.
Figure 1 shows how this looks in Firefox.</p>
<p>Figure 1: Configuring Firefox to use your SSH tunnel as a SOCKS proxy.
An easy way to test this is on your home or business network. Set up the
tunnel to a neighboring PC and surf some external Web sites. When this
works go back and change the SOCKS port number to the wrong number. This
should prevent your Web browser from connecting to any sites, and you'll
know you set up your tunnel correctly. How do you know which port
numbers to use? Port numbers above 1024 do not require root privileges,
so use these on your laptop or whatever you're using in your travels.
Always check /etc/services first to find unassigned ports. The remote
port you're binding to must be a port a server is listening on, and
there has to be a path through your firewall to get to it.</p>
<p>To learn more try the excellent [Pro OpenSSH by Michael Stahnke]
(<a class="reference external" href="http://www.apress.com/networking/openssh/9781590594766">http://www.apress.com/networking/openssh/9781590594766</a>), and my own
<a class="reference external" href="http://www.amazon.com/Linux-Networking-Cookbook-Carla-Schroder/dp/0596102488">Linux Networking
Cookbook</a>
has more on secure remote administration including SSH, OpenVPN, and
remote graphical sessions, and configuring firewalls.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Secure_Shell">Wikipedia entry
source</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="crypto-keys">
<h2>Crypto Keys</h2>
<p><a class="reference external" href="http://crypto.stackexchange.com/questions/6585/gpg-vs-pgp-vs-openssh-and-management-of-them">Source</a></p>
<pre class="literal-block">
What is the main difference of the three? Can I use only one of them for everything
(e.g. GPG for SSH authentication)
</pre>
<ul class="simple">
<li>GnuPG is an free and open-source implementation of the OpenPGP standard.</li>
<li>Symantec PGP is a proprietary implementation of the OpenPGP standard.</li>
<li>The OpenPGP standard defines ways to sign and encrypt information (like mail, other documents and code/software).</li>
<li>OpenSSH is about connection securely to remote computers. For authenticating you need some secret, usually this is a passphrase or SSH key.</li>
</ul>
<p>With OpenPGP, you hold a secret (private key) which also can be used for authenticating
yourself. It needs software support for that, and I haven't heard of some code doing this
for (Symantec) PGP, <a class="reference external" href="http://budts.be/weblog/2012/08/ssh-authentication-with-your-pgp-key">but there is a way doing this with GnuPG</a>.</p>
<pre class="literal-block">
If I encrypt my private key with a pass-phrase, is it strong enough so that if someone
steals my laptop or private key, I'm safe?
</pre>
<p>Your password encrypts your private key. The key is safe as long as your password is
safe. If your password is too weak (dictionary-attacks, not long enough, easy to
brute-force for other reasons), your key is vulnerable, too.</p>
<p>Think about how valuable your key is for an attacker and choose fitting security measures
like storing your key offline (<a class="reference external" href="http://security.stackexchange.com/a/31598/19837">in the and of this answer</a>).</p>
<pre class="literal-block">
If not, what about encrypting my private key with the scrypt algorithm?
</pre>
<p>If doing so, security depends on the password you're using for scrypt and scrypt's algorithm. You can achieve the same amount of security with a good OpenPGP password, so there is no need for additionally encrypting your key.</p>
</div>
<div class="section" id="fingerprints">
<h2>Fingerprints</h2>
<p>Generate an easier to understand fingerprint (or thumbprint) from a long public key:</p>
<pre class="literal-block">
[kevin&#64;Tardis ~]$ ssh-keygen -lf .ssh/test_rsa_key.pub
2048 d0:4a:98:88:95:65:6e:3c:59:7d:10:db:1d:00:10:40  kevin&#64;tardis.local (RSA)
</pre>
</div>


<p align="center"><a href="#">on the top</a></p>
    </div>
</div>
<div id="footer-wrapper">
<ul class="footer">
</ul><ul class="footer">
    <li class="footer">&copy;&nbsp;2016&nbsp;Kevin J. Walchko&nbsp;::</li>
    <li class="footer"><a href="../../../..">Planet Express </a>&nbsp;::</li>
    <li class="footer"><a href="https://github.com/getpelican">pelican</a></li>
    <!-- <li class="footer"><a href="http://creativecommons.org/licenses/by-nc/3.0/deed">Content CC BY-NC</a>&nbsp;::</li> -->
    <!-- <li class="footer"><a href="http://fontawesome.io">Font Awesome <i class="fa fa-flag"></i></a></li> -->
    <!-- <li class="footer"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a></li> -->
</ul>
<span><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a></span>
</div></body>
</html>